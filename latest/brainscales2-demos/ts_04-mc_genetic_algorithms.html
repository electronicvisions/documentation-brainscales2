<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>How to use Genetic Algorithms to automatically parameterize BrainScaleS-2 &mdash; BrainScaleS-2 Documentation 0.0.1 documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/visions.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Training an SNN on BrainScaleS-2 with PyTorch" href="ts_05-yin_yang.html" />
    <link rel="prev" title="Multicompartmental Neurons" href="ts_03-multicompartment.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> BrainScaleS-2 Documentation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Demos &amp; Examples</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="tutorial.html">Demos and Examples</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="ts_00-single_neuron.html">BrainScaleS-2 single neuron experiments</a></li>
<li class="toctree-l3"><a class="reference internal" href="ts_01-superspike.html">Learning with the SuperSpike rule</a></li>
<li class="toctree-l3"><a class="reference internal" href="ts_02-plasticity_rate_coding.html">BrainScaleS-2 on-chip plasticity experiment</a></li>
<li class="toctree-l3"><a class="reference internal" href="ts_03-multicompartment.html">Multicompartmental Neurons</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">How to use Genetic Algorithms to automatically parameterize BrainScaleS-2</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#constructing-the-compartment-chain-in-pynn">Constructing the Compartment Chain in PyNN</a></li>
<li class="toctree-l4"><a class="reference internal" href="#genetic-algorithm">Genetic Algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ts_05-yin_yang.html">Training an SNN on BrainScaleS-2 with PyTorch</a></li>
<li class="toctree-l3"><a class="reference internal" href="ts_06-dynamic_range.html">Exploring the dynamic range</a></li>
<li class="toctree-l3"><a class="reference internal" href="ts_07-pong.html">Pong</a></li>
<li class="toctree-l3"><a class="reference internal" href="ts_08-adex_complex_dynamics.html">Complex Neuron Dynamics with a Silicon Adaptive Exponential Integrate-and-Fire Neuron</a></li>
<li class="toctree-l3"><a class="reference internal" href="ts_09-inside_realtime_hook.html">Demonstration of inside realtime hook</a></li>
<li class="toctree-l3"><a class="reference internal" href="ts_10-multiple_configs.html">Demonstration of multiple chip-reconfigurations during an experiment</a></li>
<li class="toctree-l3"><a class="reference internal" href="tp_00-introduction.html">Introduction to matrix multiplication</a></li>
<li class="toctree-l3"><a class="reference internal" href="tp_01-properties.html">Exploring the analog MAC operation</a></li>
<li class="toctree-l3"><a class="reference internal" href="tp_02-yin_yang.html">Train DNNs on BrainScaleS-2</a></li>
<li class="toctree-l3"><a class="reference internal" href="nmpi_00-non_interactive_queue_runner.html">Introduction to the non-interactive queue runner</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial.html#executing-the-notebooks">Executing the Notebooks</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial.html#shared-hardware-resources">Shared Hardware Resources</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial.html#final-test-hardware-execution">Final test: Hardware Execution</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="girlsday.html">Wie verarbeitet unser Gehirn Informationen?</a></li>
<li class="toctree-l2"><a class="reference internal" href="fortgeschrittenen_praktikum.html">Welcome to the Advanced Physics Lab for Physicists by the Electronic Vision(s) Group</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../software_components.html">Software Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../apis.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">BrainScaleS-2 Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Welcome to the BrainScaleS-2 Demos &amp; Examples!</a> &raquo;</li>
          <li><a href="tutorial.html">Welcome to the BrainScaleS-2 Tutorial</a> &raquo;</li>
      <li>How to use Genetic Algorithms to automatically parameterize BrainScaleS-2</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/brainscales2-demos/ts_04-mc_genetic_algorithms.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="how-to-use-genetic-algorithms-to-automatically-parameterize-brainscales-2">
<h1>How to use Genetic Algorithms to automatically parameterize BrainScaleS-2<a class="headerlink" href="#how-to-use-genetic-algorithms-to-automatically-parameterize-brainscales-2" title="Permalink to this headline"></a></h1>
<p>In simulations of compartmental neurons it is a non-trivial task to find a suitable parameterization of the model <a class="reference internal" href="#vb99" id="id1"><span>[VB99]</span></a>, such that it matches observations from real neurons, like found in <a class="reference internal" href="#bll01" id="id2"><span>[BLL01]</span></a>.
In this tutorial, we’ll present an approach using genetic algorithms to automate this parameterization.
The presented approach can be used to configure the analog neurons of BrainScaleS-2 such that they can replicate experimental data.</p>
<p>In particular, we will</p>
<ul class="simple">
<li><p>create a linear chain of compartments using PyNN</p></li>
<li><p>visualize the attenuation of an excitatory postsynaptic potential
(EPSP) along the compartment chain</p></li>
<li><p>investigate how the leak conductance and the inter-compartment
conductance influence the attenuation of the EPSP</p></li>
<li><p>use genetic algorithms to automatically find appropriate parameters
for the neuron circuits to replicate a given observation</p></li>
</ul>
<p>To execute experiments on BrainScaleS-2 we use a microscheduler for whom we first have to set some environment variables:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">from</span> <span class="nn">_static.common.helpers</span> <span class="kn">import</span> <span class="n">setup_hardware_client</span>
<span class="n">setup_hardware_client</span><span class="p">()</span>
</pre></div>
</div>
<p>We’ll also configure matplotlib and import some tools.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Container</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">quantities</span> <span class="k">as</span> <span class="nn">pq</span>
<span class="kn">import</span> <span class="nn">neo</span>
<span class="kn">import</span> <span class="nn">ipywidgets</span> <span class="k">as</span> <span class="nn">widget</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.style</span> <span class="k">as</span> <span class="nn">mplstyle</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">import</span> <span class="nn">deap</span>
<span class="kn">from</span> <span class="nn">deap</span> <span class="kn">import</span> <span class="n">algorithms</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">creator</span><span class="p">,</span> <span class="n">tools</span>
<span class="kn">from</span> <span class="nn">tqdm.contrib.itertools</span> <span class="kn">import</span> <span class="n">product</span>

<span class="kn">import</span> <span class="nn">pynn_brainscales.brainscales2</span> <span class="k">as</span> <span class="nn">pynn</span>

<span class="c1"># Use default style such that colors in plots and texts match</span>
<span class="n">mplstyle</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>As a next preparation step, we load the default calibration, which is generated for every BrainScaleS-2 chip every night.
It is saved in a variable such that we can use it later when we define our experiment.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">_static.common.helpers</span> <span class="kn">import</span> <span class="n">get_nightly_calibration</span>
<span class="n">calib</span> <span class="o">=</span> <span class="n">get_nightly_calibration</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="constructing-the-compartment-chain-in-pynn">
<h2>Constructing the Compartment Chain in PyNN<a class="headerlink" href="#constructing-the-compartment-chain-in-pynn" title="Permalink to this headline"></a></h2>
<p>In the tutorial <a class="reference internal" href="ts_03-multicompartment.html"><span class="doc">Multicompartmental Neurons</span></a>, the concept of multi-compartment neurons was introduced, which are spatially structured neurons.
Here we will continue with the compartment chain experiments.
Therefore, we first create a compartment chain class, summarizing the experiments of the <a class="reference internal" href="ts_03-multicompartment.html"><span class="doc">Multicompartmental Neurons</span></a> tutorial and extending it with further functionality for the experiments of this tutorial.
Upon initialization the class creates a compartment chain of provided length.
Additionally, the first compartment is connected to an external population (refer to <a class="reference internal" href="#figure-1">figure 1</a>) that will spike at a specified point in time.
This causes an EPSP that travels along the chain.</p>
<div class="figure align-center" id="id8">
<span id="figure-1"></span><a class="reference internal image-reference" href="../_images/ga_chain_external_pop.png"><img alt="../_images/ga_chain_external_pop.png" src="../_images/ga_chain_external_pop.png" style="width: 50%;" /></a>
<p class="caption"><span class="caption-text">Figure 1: Compartment chain of length 5 and external population connecting to the first compartment.</span><a class="headerlink" href="#id8" title="Permalink to this image"></a></p>
</div>
<p>The class functions are summarized in the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">create_input_projection</span></code>: Generates an external population of size <code class="docutils literal notranslate"><span class="pre">inputs</span></code> and connects it to the first compartment.
All neurons of the external population will spike simultaneously, introducing an EPSP in the compartment chain.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">set_conductances</span></code>: Sets the leak and inter-compartment conductance to the provided values.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">record_membrane</span></code>: Records the experiment, i.e. the EPSP traveling along the compartment chain.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">extract_psp_amplitudes</span></code>: Extracts the amplitudes of the EPSP in each compartment.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fit_length_constant</span></code>: Fit an exponential function to the EPSP amplitudes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">run_and_eval</span></code>: This function executes the experiment and returns the fit parameters and the amplitudes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">evaluate</span></code>: This function calls <code class="docutils literal notranslate"><span class="pre">run_and_eval</span></code> and compares the extracted length constant to a target.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fitfunc</span></code>: Defines an exponential function of the form <span class="math notranslate nohighlight">\(f(x) = A \cdot \exp\left(-\frac{x}{\lambda}\right) + c\)</span>.</p></li>
</ul>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CompartmentChain</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Creates a compartment chain of provided length upon initialization and</span>
<span class="sd">    supplies further functionalities to run and evaluate experiments.</span>

<span class="sd">    :ivar length: Lenght of the compartment chain.</span>
<span class="sd">    :ivar compartments: Compartments of the chain.</span>
<span class="sd">    :ivar runtime: Experiment runtime in ms.</span>
<span class="sd">    :ivar spike_time: Time of input spike.</span>
<span class="sd">    :ivar projection: Projections between external population and first</span>
<span class="sd">        compartment of the chain.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">weight</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">63</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compartments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_chain</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runtime</span> <span class="o">=</span> <span class="mf">0.15</span> <span class="o">*</span> <span class="n">pq</span><span class="o">.</span><span class="n">ms</span>  <span class="c1"># (hw)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spike_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">runtime</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># (hw)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_input_projection</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_chain</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">pynn</span><span class="o">.</span><span class="n">PopulationView</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create linear compartment chain.</span>

<span class="sd">        A compartment will be constructed out of two neuron circuits.</span>
<span class="sd">        Thereby, one neuron circuit will handle the parameters of a</span>
<span class="sd">        compartment.</span>

<span class="sd">        :returns: List containing every compartment of the chain.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">pop</span> <span class="o">=</span> <span class="n">pynn</span><span class="o">.</span><span class="n">Population</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pynn</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">HXNeuron</span><span class="p">())</span>

        <span class="c1"># Combine two neuron circuits to one compartment; &quot;disable&quot; second</span>
        <span class="c1"># neuron circuit</span>
        <span class="n">pynn</span><span class="o">.</span><span class="n">PopulationView</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
            <span class="n">multicompartment_connect_right</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">leak_i_bias</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">leak_enable_division</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">membrane_capacitance_capacitance</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Enable direct connection to somatic line for even neuron circuits</span>
        <span class="c1"># (don&#39;t connect first neuron circuit)</span>
        <span class="n">pynn</span><span class="o">.</span><span class="n">PopulationView</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
            <span class="n">multicompartment_connect_soma</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Connect resistor to somatic line and close connection to the right</span>
        <span class="c1"># for uneven circuits (don&#39;t connect last neuron circuit)</span>
        <span class="c1"># Note: We enable both leak division and inter-compartment</span>
        <span class="c1"># conductance division here since it results in larger length</span>
        <span class="c1"># constants. This allows the EPSP to travel further down the chain</span>
        <span class="c1"># and is chosen for the sake of this tutorial. Real neurons might</span>
        <span class="c1"># exhibit different dynamical properties which might need other</span>
        <span class="c1"># settings for those two parameters.</span>
        <span class="n">pynn</span><span class="o">.</span><span class="n">PopulationView</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
            <span class="n">multicompartment_enable_conductance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">multicompartment_i_bias_nmda</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span>
            <span class="n">multicompartment_connect_soma_right</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">multicompartment_enable_conductance_division</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">leak_enable_division</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Disable spiking</span>
        <span class="n">pop</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">threshold_enable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Every uneven neuron circuit controls the capacitance, resistance,</span>
        <span class="c1"># leak, ... of a single compartment. Return views on these circuits</span>
        <span class="c1"># as compartments</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">pynn</span><span class="o">.</span><span class="n">PopulationView</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span>
                <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">create_input_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pynn</span><span class="o">.</span><span class="n">Projection</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Set projection from an external population of size `inputs`, which</span>
<span class="sd">        elicits a spike at the time defined by spike_time, to the first</span>
<span class="sd">        compartment.</span>

<span class="sd">        :param inputs: Size of external population.</span>
<span class="sd">        :returns: Projection from input population to first compartment.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Inject stimulus in first compartment</span>
        <span class="n">pop_in</span> <span class="o">=</span> <span class="n">pynn</span><span class="o">.</span><span class="n">Population</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">pynn</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">SpikeSourceArray</span><span class="p">(</span>
            <span class="n">spike_times</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_time</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">))]))</span>

        <span class="c1"># Note: the weight will be set later</span>
        <span class="n">synapse_type</span> <span class="o">=</span> <span class="n">pynn</span><span class="o">.</span><span class="n">standardmodels</span><span class="o">.</span><span class="n">synapses</span><span class="o">.</span><span class="n">StaticSynapse</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pynn</span><span class="o">.</span><span class="n">Projection</span><span class="p">(</span>
            <span class="n">pop_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartments</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pynn</span><span class="o">.</span><span class="n">AllToAllConnector</span><span class="p">(),</span>
            <span class="n">synapse_type</span><span class="o">=</span><span class="n">synapse_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_conductances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leak_conductance</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                         <span class="n">inter_compartment_conductance</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Set leak and inter-compartment conductance of the chain.</span>

<span class="sd">        Both the leak_conductance and the inter_compartment_conductance</span>
<span class="sd">        have a parameter range from 0 to 1022.</span>

<span class="sd">        :param leak_conductance: Leak conductance that will be set.</span>
<span class="sd">        :param inter_compartment_conductance: Inter-compartment conductance</span>
<span class="sd">            that will be set.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartments</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">g_leak</span> <span class="o">=</span> <span class="n">leak_conductance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">g_ic</span> <span class="o">=</span> <span class="n">inter_compartment_conductance</span>
            <span class="n">comp</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="n">multicompartment_i_bias_nmda</span><span class="o">=</span><span class="n">inter_compartment_conductance</span><span class="p">)</span>
            <span class="n">comp</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">leak_i_bias</span><span class="o">=</span><span class="n">leak_conductance</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">record_membrane</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">neo</span><span class="o">.</span><span class="n">IrregularlySampledSignal</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Record the membrane of each compartment of the chain.</span>

<span class="sd">        The experiment is repeated `self.length` times since the MADC can only</span>
<span class="sd">        record one neuron circuit&#39;s membrane at a time.</span>

<span class="sd">        :returns: Membrane traces of each compartment.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Run on hardware and record membrane potentials</span>
        <span class="n">membrane_traces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n_comp</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compartments</span><span class="p">):</span>
            <span class="n">comp</span><span class="o">.</span><span class="n">record</span><span class="p">([</span><span class="s1">&#39;v&#39;</span><span class="p">])</span>

            <span class="n">pynn</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runtime</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span><span class="p">)</span>
            <span class="n">pynn</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

            <span class="n">sig</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">irregularlysampledsignals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sig</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">compartment</span><span class="o">=</span><span class="n">n_comp</span><span class="p">,</span> <span class="n">spike_time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_time</span><span class="p">)</span>

            <span class="n">membrane_traces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>

            <span class="n">comp</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">membrane_traces</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">extract_psp_amplitudes</span><span class="p">(</span>
            <span class="n">membrane_traces</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">neo</span><span class="o">.</span><span class="n">IrregularlySampledSignal</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Extract the PSP amplitudes from membrane recordings.</span>

<span class="sd">        :param traces: Analog signal for each compartment in the chain.</span>
<span class="sd">        :returns: Amplitudes of PSP (difference between maximum and baseline).</span>
<span class="sd">            The amplitudes are calculated for each compartment.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">amplitudes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="n">membrane_traces</span><span class="p">:</span>
            <span class="n">spike_time</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">annotations</span><span class="p">[</span><span class="s1">&#39;spike_time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>

            <span class="c1"># use membrane voltage before first spike as baseline</span>
            <span class="n">baseline</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">time_slice</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">t_start</span><span class="p">,</span> <span class="n">spike_time</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

            <span class="n">amplitudes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">baseline</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fit_length_constant</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">amplitudes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Fit an exponential decay to the PSP amplitudes in the compartments.</span>

<span class="sd">        :param amplitudes: Amplitudes of the EPSP for each compartment in the</span>
<span class="sd">            chain.</span>
<span class="sd">        :returns: Fit parameters and covariance matrix for the fit to the</span>
<span class="sd">            exponential.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">norm_amp</span> <span class="o">=</span> <span class="n">amplitudes</span> <span class="o">/</span> <span class="n">amplitudes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">compartments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">))</span>

        <span class="c1"># initial guess for fit parameters</span>
        <span class="n">guessed_lambda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">norm_amp</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">))</span>
        <span class="n">p_0</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lambda_&#39;</span><span class="p">:</span> <span class="n">guessed_lambda</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">:</span> <span class="n">norm_amp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
               <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="n">norm_amp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">norm_amp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]}</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lambda_&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span>
                  <span class="s1">&#39;offset&#39;</span><span class="p">:</span> <span class="n">p_0</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
                  <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]}</span>

        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">fitfunc</span><span class="p">,</span> <span class="n">compartments</span><span class="p">,</span> <span class="n">norm_amp</span><span class="p">,</span>
            <span class="n">p0</span><span class="o">=</span><span class="p">[</span><span class="n">p_0</span><span class="p">[</span><span class="s1">&#39;lambda_&#39;</span><span class="p">],</span> <span class="n">p_0</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">],</span> <span class="n">p_0</span><span class="p">[</span><span class="s1">&#39;lambda_&#39;</span><span class="p">]],</span>
            <span class="n">bounds</span><span class="o">=</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;lambda_&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                     <span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="p">[</span><span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;lambda_&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                     <span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]]))</span>

        <span class="k">return</span> <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span>

    <span class="k">def</span> <span class="nf">run_and_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leak_conductance</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                     <span class="n">inter_compartment_conductance</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Executes the experiment and fits an exponential to the maximum</span>
<span class="sd">        amplitude of the EPSP in each compartment.</span>

<span class="sd">        The fit parameters and the extracted amplitudes are then returned.</span>

<span class="sd">        :param leak_conductance: Leak conductance that will be set.</span>
<span class="sd">        :param inter_compartment_conductance: Inter-compartment conductance</span>
<span class="sd">            that will be set.</span>
<span class="sd">        :returns: Fit parameters, estimated covariance of fit parameters</span>
<span class="sd">            and amplitudes of the EPSP in each compartment.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_conductances</span><span class="p">(</span>
            <span class="n">leak_conductance</span><span class="o">=</span><span class="n">leak_conductance</span><span class="p">,</span>
            <span class="n">inter_compartment_conductance</span><span class="o">=</span><span class="n">inter_compartment_conductance</span><span class="p">)</span>

        <span class="n">membrane_traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_membrane</span><span class="p">()</span>
        <span class="n">amplitudes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_psp_amplitudes</span><span class="p">(</span><span class="n">membrane_traces</span><span class="p">)</span>
        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_length_constant</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span><span class="p">,</span> <span class="n">amplitudes</span>

    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">individual</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Evaluation function used for the genetic algorithm.</span>

<span class="sd">        Executes the experiment and fits an exponential to the maximum</span>
<span class="sd">        amplitude of the EPSP in each compartment.</span>

<span class="sd">        :param individual: Individual representing the settings of the leak and</span>
<span class="sd">            inter-compartment conductance.</span>
<span class="sd">        :param target: Target length constant.</span>
<span class="sd">        :returns: The absolute difference between the target and the</span>
<span class="sd">            individual&#39;s length constant.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">popt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_and_eval</span><span class="p">(</span>
            <span class="n">leak_conductance</span><span class="o">=</span><span class="n">individual</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">inter_compartment_conductance</span><span class="o">=</span><span class="n">individual</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">popt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">target</span><span class="p">),)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fitfunc</span><span class="p">(</span><span class="n">location</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">length_const</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                <span class="n">offset</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Exponential function with offset.</span>

<span class="sd">        :param location: Numerator inside the exponential.</span>
<span class="sd">        :param length_const: Denominator inside the exponential.</span>
<span class="sd">        :param offset: Y-offset of the exponential.</span>
<span class="sd">        :param scale: Amplitude at Y-intercept.</span>
<span class="sd">        :returns: Function evaluation provided the parameters.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">location</span> <span class="o">/</span> <span class="n">length_const</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span>
</pre></div>
</div>
<div class="section" id="overview-of-the-experiment">
<h3>Overview of the experiment<a class="headerlink" href="#overview-of-the-experiment" title="Permalink to this headline"></a></h3>
<p>We run the experiment and visualize the attenuation of the EPSP along the chain.
All plotting functions used in this tutorial are defined in this <a class="reference external" href="_static/tutorial/ga_mc_helpers.py">helper file</a>.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">_static.tutorial.ga_mc_helpers</span> <span class="k">as</span> <span class="nn">helpers</span>


<span class="n">pynn</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">initial_config</span><span class="o">=</span><span class="n">calib</span><span class="p">)</span>
<span class="n">compartment_chain</span> <span class="o">=</span> <span class="n">CompartmentChain</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">compartment_chain</span><span class="o">.</span><span class="n">set_conductances</span><span class="p">(</span>
    <span class="n">leak_conductance</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
    <span class="n">inter_compartment_conductance</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">membrane_traces</span> <span class="o">=</span> <span class="n">compartment_chain</span><span class="o">.</span><span class="n">record_membrane</span><span class="p">()</span>
<span class="n">helpers</span><span class="o">.</span><span class="n">plot_membrane_traces</span><span class="p">(</span><span class="n">membrane_traces</span><span class="p">,</span> <span class="n">compartment_chain</span><span class="p">)</span>
</pre></div>
</div>
<p>Clearly, the attenuation of the EPSP with increasing distance from the EPSP initiation zone can be seen.
The red dashed lines indicate the maximal amplitude <span class="math notranslate nohighlight">\(U_\mathrm{max}\)</span> of the EPSP in the respective compartment.
Please note that the baseline was subtracted in the second row of the figure since each neuron circuit has an individual recording offset.</p>
<p>Next, we want to observe how the attenuation is affected by the two following parameters:</p>
<ul class="simple">
<li><p>the leak conductance <span class="math notranslate nohighlight">\(g_\mathrm{leak}\)</span></p></li>
<li><p>the inter-compartment conductance <span class="math notranslate nohighlight">\(g_\mathrm{ic}\)</span>.</p></li>
</ul>
<p>By varying those two parameters, we can see how the maximal EPSP amplitudes change.
Furthermore, we fit an exponential function <span class="math notranslate nohighlight">\(U_\mathrm{max}(x)=\exp(-x/\lambda_\mathrm{emp})+c\)</span> to the decay of the EPSP amplitudes normed to the amplitude of the first compartment.
The function parameter <span class="math notranslate nohighlight">\(\lambda_\mathrm{emp}\)</span> is the empirically determined length constant and approximately describes at which distance a signal decays to <span class="math notranslate nohighlight">\(1/e\)</span> of its original amplitude.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">old_data</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">Slider</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">widget</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">,</span> <span class="n">continuous_update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">BoundedInt</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">widget</span><span class="o">.</span><span class="n">BoundedIntText</span><span class="p">,</span> <span class="n">continuous_update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="nd">@widget</span><span class="o">.</span><span class="n">interact</span><span class="p">(</span>
    <span class="n">g_leak</span><span class="o">=</span><span class="n">Slider</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">1022</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                  <span class="n">description</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$g_{\mathrm</span><span class="si">{leak}</span><span class="s1">}$&#39;</span><span class="p">),</span>
    <span class="n">g_ic</span><span class="o">=</span><span class="n">Slider</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">1022</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                <span class="n">description</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$g_{\mathrm</span><span class="si">{ic}</span><span class="s1">}$&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">run_experiment</span><span class="p">(</span><span class="n">g_leak</span><span class="p">,</span> <span class="n">g_ic</span><span class="p">):</span>
    <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span><span class="p">,</span> <span class="n">amplitudes</span> <span class="o">=</span> <span class="n">compartment_chain</span><span class="o">.</span><span class="n">run_and_eval</span><span class="p">(</span><span class="n">g_leak</span><span class="p">,</span> <span class="n">g_ic</span><span class="p">)</span>
    <span class="n">helpers</span><span class="o">.</span><span class="n">visualize_experiment</span><span class="p">(</span>
        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span><span class="p">,</span> <span class="n">amplitudes</span><span class="p">,</span> <span class="n">compartment_chain</span><span class="p">,</span> <span class="n">old_data</span><span class="p">)</span>
</pre></div>
</div>
<p>In the following cell, you can compare the attenuation behavior of different parameterizations:
1. Set “Old runs” to the number of configurations you want to compare.
1. Use the sliders from the previous cell to set <span class="math notranslate nohighlight">\(g_\mathrm{leak}\)</span> and <span class="math notranslate nohighlight">\(g_\mathrm{ic}\)</span> to a configuration you want to investigate.
1. Repeat from 2. for the next configuration you want to compare.
1. Press “Display old runs” to display the “Old runs” last configurations.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">w</span> <span class="o">=</span> <span class="n">widget</span><span class="o">.</span><span class="n">interact_manual</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">manual_name</span><span class="o">=</span><span class="s2">&quot;Display old runs&quot;</span><span class="p">)</span>

<span class="n">w</span><span class="p">(</span><span class="n">helpers</span><span class="o">.</span><span class="n">display_old_runs</span><span class="p">,</span> <span class="n">archive</span><span class="o">=</span><span class="n">widget</span><span class="o">.</span><span class="n">fixed</span><span class="p">(</span><span class="n">old_data</span><span class="p">),</span>
  <span class="n">n_last_runs</span><span class="o">=</span><span class="n">BoundedInt</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                         <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Old runs&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>In order to get a better understanding of how the conductances influence the length constant <span class="math notranslate nohighlight">\(\lambda_\mathrm{emp}\)</span>, we sweep both parameters in a grid search.
Note that depending on the <code class="docutils literal notranslate"><span class="pre">GRID_LENGTH</span></code> this might take a few minutes.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">GRID_LENGTH</span> <span class="o">=</span> <span class="mi">8</span>
</pre></div>
</div>
<div class="test html-display-none highlight-ipython3 notranslate"><div class="highlight"><pre><span></span> <span class="n">GRID_LENGTH</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lambdas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">GRID_LENGTH</span><span class="p">,</span> <span class="n">GRID_LENGTH</span><span class="p">))</span>

<span class="n">conductances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">GRID_LENGTH</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">[</span><span class="n">g_leak</span><span class="p">,</span> <span class="n">g_ic</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="n">conductances</span><span class="p">,</span> <span class="n">conductances</span><span class="p">)):</span>
    <span class="n">popt</span> <span class="o">=</span> <span class="n">compartment_chain</span><span class="o">.</span><span class="n">run_and_eval</span><span class="p">(</span>
        <span class="n">leak_conductance</span><span class="o">=</span><span class="n">g_leak</span><span class="p">,</span> <span class="n">inter_compartment_conductance</span><span class="o">=</span><span class="n">g_ic</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">lambdas</span><span class="p">[</span><span class="n">idx</span> <span class="o">%</span> <span class="n">GRID_LENGTH</span><span class="p">,</span> <span class="n">idx</span> <span class="o">//</span> <span class="n">GRID_LENGTH</span><span class="p">]</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Finally, we visualize the dependency of <span class="math notranslate nohighlight">\(\lambda_\mathrm{emp}\)</span> on <span class="math notranslate nohighlight">\(g_\mathrm{leak}\)</span> and <span class="math notranslate nohighlight">\(g_\mathrm{ic}\)</span>.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="mf">1.1</span><span class="p">),</span> <span class="n">tight_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">gridspec_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;height_ratios&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">]})</span>
<span class="n">helpers</span><span class="o">.</span><span class="n">plot_grid_search</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">lambdas</span><span class="p">,</span> <span class="n">conductances</span><span class="p">)</span>
</pre></div>
</div>
<p>From the visualization of the grid search we can observe that a higher <span class="math notranslate nohighlight">\(g_\mathrm{ic}\)</span> will result in a larger <span class="math notranslate nohighlight">\(\lambda_\mathrm{emp}\)</span>.
Furthermore, decreasing <span class="math notranslate nohighlight">\(g_\mathrm{leak}\)</span> can also result in larger <span class="math notranslate nohighlight">\(\lambda_\mathrm{emp}\)</span>, as the charge leaks more slowly from the membrane and therefore the EPSP can travel further down the chain.</p>
<p>Through the grid search, we already obtained an estimate of how to choose our parameters <span class="math notranslate nohighlight">\(g_\mathrm{leak}\)</span> and <span class="math notranslate nohighlight">\(g_\mathrm{ic}\)</span> to obtain a certain <span class="math notranslate nohighlight">\(\lambda_\mathrm{emp}\)</span>.
However, if we want to find a precise setting, this brute force approach will become slow as a higher grid resolution will be necessary.
Further, when adding more dimensions, the algorithm scales with <span class="math notranslate nohighlight">\(N^d\)</span>, where <span class="math notranslate nohighlight">\(N\)</span> is the number of grid steps and <span class="math notranslate nohighlight">\(d\)</span> the number of dimensions.
So when searching only one operating point, we can save a lot of computation time by not measuring all combinations but applying a genetic algorithm.
Note that in contrast to the usual algorithms we use for calibration, like a binary search, this does not require assumptions about the hardware.</p>
<p>We will now introduce genetic algorithms and use one to optimize <span class="math notranslate nohighlight">\(g_\mathrm{leak}\)</span> and <span class="math notranslate nohighlight">\(g_\mathrm{ic}\)</span> such that they result in a desired <span class="math notranslate nohighlight">\(\lambda_\mathrm{emp}\)</span>.
Note that this is only an illustration, as an operating point may usually be constrained by more target parameters, like a desired membrane time constant or given amplitudes per compartment.
We will use the module deap <a class="reference internal" href="#for-12" id="id3"><span>[For+12]</span></a> to implement the genetic algorithm.</p>
</div>
</div>
<div class="section" id="genetic-algorithm">
<h2>Genetic Algorithm<a class="headerlink" href="#genetic-algorithm" title="Permalink to this headline"></a></h2>
<p>Genetic algorithms can be used for derivative-free optimizations and search tasks.
The name is inspired by natural evolution as the algorithm borrows concepts from it <a class="reference internal" href="#gol89" id="id4"><span>[Gol89]</span></a>.</p>
<p>First, the algorithm creates a population of initial solutions.
Every solution - referred to as an individual - is composed of genes that can be represented as numerical values.
The numerical values are chosen randomly at the beginning of the algorithm.
In an iterative procedure, individuals are mutated, recombined and selected, based on their fitness, i.e. how well they solve the problem.
The iterations of this procedure are also called generations.
This process stops if a satisfactory solution is found or until a predefined number of generations is reached.</p>
<p>In the following, we will implement the genetic algorithm sketched in <a class="reference internal" href="#figure-2">figure 2</a> below.
For our problem our individuals will consist out of two genes, which will be integer values describing the leak and inter-compartment conductance, bound to their respective limits.</p>
<p>The population is initialized by randomly creating <span class="math notranslate nohighlight">\(n=\)</span><code class="docutils literal notranslate"><span class="pre">POPSIZE</span></code> individuals by drawing their genes from a uniform distributions over the search-boundaries.</p>
<p>The evaluation-step is then done on BrainScaleS-2, where we configure the conductances according to an individual and run our above defined experiment.
The fitness of that individual is then calculated by taking the absolute difference between the measured length constant <span class="math notranslate nohighlight">\(\lambda_\mathrm{emp}\)</span> and a predefined target length constant <span class="math notranslate nohighlight">\(\hat{\lambda}_\mathrm{emp}\)</span>.
Next, individuals of the population are selected based on their fitness.
Here we use tournament selection, which randomly picks <code class="docutils literal notranslate"><span class="pre">TOURNSIZE</span></code> individuals and selects the fittest of those.
All individuals <a class="footnote-reference brackets" href="#id6" id="id5">1</a> of the tournament are then put back to the original population and the next tournament is started.
Overall <code class="docutils literal notranslate"><span class="pre">POPSIZE</span></code> tournaments are run such that <code class="docutils literal notranslate"><span class="pre">POPSIZE</span></code> individuals are selected.</p>
<p>Subsequently, the selected individuals are mutated and recombined.
For recombination each individual is picked with probability <code class="docutils literal notranslate"><span class="pre">CXPB</span></code> and then from pairs of those picked individuals offspring is generated by mixing their genes (for details see <a class="reference internal" href="#table-1">table 1</a>).
This functionality is provided by the <code class="docutils literal notranslate"><span class="pre">deap</span></code> method <code class="docutils literal notranslate"><span class="pre">tools.cxOnePoint</span></code>.
An individual is mutated using <code class="docutils literal notranslate"><span class="pre">deap</span></code>’s <code class="docutils literal notranslate"><span class="pre">tools.mutUniformInt</span></code> method.
This will happen with the probability <code class="docutils literal notranslate"><span class="pre">MUTPB</span></code> where each gene is randomly altered with probability <code class="docutils literal notranslate"><span class="pre">INDPB</span></code> (see <a class="reference internal" href="#table-2">table 2</a>).</p>
<p>Finally, after those steps we end up with the next generation.
Then the whole process - starting from the evaluation-step - repeats until the <code class="docutils literal notranslate"><span class="pre">NGEN</span></code>-th generation is reached.
Ultimately, the fittest individual approximates a solution to our problem.</p>
<dl class="footnote brackets">
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id5">1</a></span></dt>
<dd><p>Including the just picked individuals.
Note: This way the same individual can be picked multiple times for generating the next generation.
Therefore <code class="docutils literal notranslate"><span class="pre">TOURNSIZE</span></code> should not be chosen too large to maintain exploration of the solution space.</p>
</dd>
</dl>
<div class="figure align-center" id="id9">
<span id="figure-2"></span><a class="reference internal image-reference" href="../_images/ga_mc_flowchart.png"><img alt="../_images/ga_mc_flowchart.png" src="../_images/ga_mc_flowchart.png" style="width: 50%;" /></a>
<p class="caption"><span class="caption-text">Figure 2: Flowchart of a genetic algorithm.</span><a class="headerlink" href="#id9" title="Permalink to this image"></a></p>
</div>
<span id="table-1"></span><table class="docutils align-default" id="id10">
<caption><span class="caption-text">Table 1: Recombination of two parents creating two offspring individuals.</span><a class="headerlink" href="#id10" title="Permalink to this table"></a></caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Individual</p></th>
<th class="head"><p>Gene <span class="math notranslate nohighlight">\(g_\mathrm{l}\)</span></p></th>
<th class="head"><p>Gene <span class="math notranslate nohighlight">\(g_\mathrm{ic}\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Parent 1</p></td>
<td><p>64</p></td>
<td><p>852</p></td>
</tr>
<tr class="row-odd"><td><p>Parent 2</p></td>
<td><p>263</p></td>
<td><p>37</p></td>
</tr>
<tr class="row-even"><td><p>Offspring 1</p></td>
<td><p>64</p></td>
<td><p>37</p></td>
</tr>
<tr class="row-odd"><td><p>Offspring 2</p></td>
<td><p>263</p></td>
<td><p>852</p></td>
</tr>
</tbody>
</table>
<span id="table-2"></span><table class="docutils align-default" id="id11">
<caption><span class="caption-text">Table 2: Mutation of an individual.</span><a class="headerlink" href="#id11" title="Permalink to this table"></a></caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Individual</p></th>
<th class="head"><p>Gene <span class="math notranslate nohighlight">\(g_\mathrm{l}\)</span></p></th>
<th class="head"><p>Gene <span class="math notranslate nohighlight">\(g_\mathrm{ic}\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Parent</p></td>
<td><p>64</p></td>
<td><p>852</p></td>
</tr>
<tr class="row-odd"><td><p>Offspring</p></td>
<td><p>64</p></td>
<td><p>663</p></td>
</tr>
</tbody>
</table>
<p>Most of functionality we need is already provided by <code class="docutils literal notranslate"><span class="pre">deap</span></code> and we only have to pick the desired functions and hyper-parameters.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># parameter limits g_leak and g_ic</span>
<span class="n">limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1022</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1022</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>

<span class="c1"># number of individuals which will be picked for tournament selection</span>
<span class="n">TOURNSIZE</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">MUTPB</span> <span class="o">=</span> <span class="mf">0.2</span>  <span class="c1"># probability that individual is mutated</span>
<span class="c1"># probability that a gene is mutated if individual is picked for mutation</span>
<span class="n">INDPB</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">CXPB</span> <span class="o">=</span> <span class="mf">0.3</span>  <span class="c1"># probability that this individual will be picked for crossover</span>
<span class="n">NGEN</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># number of generations until algorithm stops</span>
<span class="n">POPSIZE</span> <span class="o">=</span> <span class="mi">25</span>  <span class="c1"># number of individuals within each generation</span>

<span class="c1"># container for various tools</span>
<span class="n">toolbox</span> <span class="o">=</span> <span class="n">deap</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">Toolbox</span><span class="p">()</span>

<span class="c1"># define individual if not yet done</span>
<span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">deap</span><span class="o">.</span><span class="n">creator</span><span class="p">,</span> <span class="s2">&quot;FitnessMin&quot;</span><span class="p">):</span>
    <span class="n">deap</span><span class="o">.</span><span class="n">creator</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s2">&quot;FitnessMin&quot;</span><span class="p">,</span> <span class="n">deap</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">Fitness</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,))</span>
    <span class="n">deap</span><span class="o">.</span><span class="n">creator</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s2">&quot;Individual&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">fitness</span><span class="o">=</span><span class="n">deap</span><span class="o">.</span><span class="n">creator</span><span class="o">.</span><span class="n">FitnessMin</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">create_individual</span><span class="p">(</span><span class="n">lower_limit</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                      <span class="n">upper_limit</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Creates an array of random integers of size 2 bounded to the provided</span>
<span class="sd">    limits.</span>

<span class="sd">    Values are drawn from a uniform distribution within</span>
<span class="sd">    [lower_limit, upper_limit] for the respective gene.</span>

<span class="sd">    :param lower_limit: Lower limits.</span>
<span class="sd">    :param upper_limit: Upper limits.</span>
<span class="sd">    :returns: Individual.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">lower_limit</span><span class="p">,</span> <span class="n">upper_limit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">deap</span><span class="o">.</span><span class="n">creator</span><span class="o">.</span><span class="n">Individual</span><span class="p">(</span><span class="n">ind</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>


<span class="n">toolbox</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;individual&quot;</span><span class="p">,</span> <span class="n">create_individual</span><span class="p">,</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">toolbox</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;population&quot;</span><span class="p">,</span> <span class="n">deap</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">initRepeat</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">toolbox</span><span class="o">.</span><span class="n">individual</span><span class="p">)</span>

<span class="c1"># define evolutionary operators</span>
<span class="n">toolbox</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;select&quot;</span><span class="p">,</span> <span class="n">deap</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">selTournament</span><span class="p">,</span> <span class="n">tournsize</span><span class="o">=</span><span class="n">TOURNSIZE</span><span class="p">)</span>
<span class="n">toolbox</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;mate&quot;</span><span class="p">,</span> <span class="n">deap</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">cxOnePoint</span><span class="p">)</span>
<span class="n">toolbox</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;mutate&quot;</span><span class="p">,</span> <span class="n">deap</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">mutUniformInt</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                 <span class="n">up</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">indpb</span><span class="o">=</span><span class="n">INDPB</span><span class="p">)</span>
</pre></div>
</div>
<div class="test html-display-none highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">NGEN</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">POPSIZE</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div>
</div>
<p>We just defined the hyper-parameters of the genetic algorithm and how our individuals are generated and altered by the evolutionary operators.</p>
<p>Now, we only need to define the target length constant and the evaluation function.
The execution of experiments will suffer from trial-to-trial variations, which originate from the analog nature of the hardware.
Therefore, the measured length constants might vary from run to run even though the configuration is the same.
In order to later have the chance to interpret the results with respect to those trial-to-trial variations we define our target to be the averaged observed length constant found in 10 initial experiment runs using a fixed parameterization for <span class="math notranslate nohighlight">\(g_\mathrm{l}\)</span> and <span class="math notranslate nohighlight">\(g_\mathrm{ic}\)</span>.
From those 10 measurements we can calculate the standard deviation of the measured length constants, which can function as a rough estimation of the expected trial-to-trial variation during the experiment.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># fixed conductance parameters to generate target</span>
<span class="n">g_leak</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">g_ic</span> <span class="o">=</span> <span class="mi">500</span>

<span class="n">targets</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">popt</span> <span class="o">=</span> <span class="n">compartment_chain</span><span class="o">.</span><span class="n">run_and_eval</span><span class="p">(</span><span class="n">g_leak</span><span class="p">,</span> <span class="n">g_ic</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">popt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Average target value: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> +- &quot;</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> compartments&quot;</span><span class="p">)</span>

<span class="c1"># evaluation function</span>
<span class="n">toolbox</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;evaluate&quot;</span><span class="p">,</span> <span class="n">compartment_chain</span><span class="o">.</span><span class="n">evaluate</span><span class="p">,</span>
                 <span class="n">target</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">targets</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that we are interested in the individuals which reproduce our desired target length constant <span class="math notranslate nohighlight">\(\hat{\lambda}\)</span> as precise as possible.
Therefore, our evaluation function calculates the deviation from an individual’s length constant <span class="math notranslate nohighlight">\(\lambda_{\mathrm{emp}}\)</span> to our desired target length constant <span class="math notranslate nohighlight">\(\hat{\lambda}\)</span>:</p>
<div class="math notranslate nohighlight">
\[f = | \lambda_{\mathrm{emp}} - \hat{\lambda} | .\]</div>
<p>This value is called fitness and for our task we want to minimize it.
Here, this is achieved by choosing a negative weight in deap’s fitness function.
During selection, this ensures, that individuals with a smaller fitness value are favored over those with a larger one.</p>
<p>In the following, we define more visualization functions that will show how the population evolves in time and consequently run the genetic algorithm with the hyper-parameters defined above.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="mf">1.1</span><span class="p">),</span> <span class="n">tight_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">gridspec_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;height_ratios&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">]})</span>
<span class="n">helpers</span><span class="o">.</span><span class="n">plot_fitness_population</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">POPSIZE</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">targets</span><span class="p">))</span>
<span class="n">helpers</span><span class="o">.</span><span class="n">plot_grid_search</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">lambdas</span><span class="p">,</span> <span class="n">conductances</span><span class="p">)</span>
<span class="c1"># create empty scatter plot to later visualize the distribution of the</span>
<span class="c1"># population over the grid plot</span>
<span class="n">scat</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span>
                          <span class="n">s</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
<span class="c1"># hide plot in bottom right</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">widget</span><span class="o">.</span><span class="n">Output</span><span class="p">()</span>
<span class="n">display</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">mean_fitness</span><span class="p">(</span><span class="n">population</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the mean fitness of a population.</span>

<span class="sd">    :param population: Population containing individuals.</span>
<span class="sd">    :returns: Mean fitness of population.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">ind</span><span class="o">.</span><span class="n">fitness</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">population</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">min_fitness</span><span class="p">(</span><span class="n">population</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find minimum fitness of a population.</span>

<span class="sd">    :param population: Population containing individuals.</span>
<span class="sd">    :returns: Minimal fitness within a population.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">ind</span><span class="o">.</span><span class="n">fitness</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">population</span><span class="p">])</span>


<span class="n">stats</span> <span class="o">=</span> <span class="n">deap</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">Statistics</span><span class="p">(</span><span class="k">lambda</span> <span class="n">ind</span><span class="p">:</span> <span class="n">ind</span><span class="p">)</span>
<span class="n">stats</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;mean fitness&quot;</span><span class="p">,</span> <span class="n">mean_fitness</span><span class="p">)</span>
<span class="n">stats</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;min fitness&quot;</span><span class="p">,</span> <span class="n">min_fitness</span><span class="p">)</span>
<span class="n">stats</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">helpers</span><span class="o">.</span><span class="n">visualization</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">scat</span><span class="o">=</span><span class="n">scat</span><span class="p">,</span>
               <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
<span class="n">pop</span><span class="p">,</span> <span class="n">log</span> <span class="o">=</span> <span class="n">deap</span><span class="o">.</span><span class="n">algorithms</span><span class="o">.</span><span class="n">eaSimple</span><span class="p">(</span>
    <span class="n">toolbox</span><span class="o">.</span><span class="n">population</span><span class="p">(</span><span class="n">POPSIZE</span><span class="p">),</span> <span class="n">toolbox</span><span class="p">,</span> <span class="n">cxpb</span><span class="o">=</span><span class="n">CXPB</span><span class="p">,</span> <span class="n">mutpb</span><span class="o">=</span><span class="n">MUTPB</span><span class="p">,</span> <span class="n">ngen</span><span class="o">=</span><span class="n">NGEN</span><span class="p">,</span>
    <span class="n">stats</span><span class="o">=</span><span class="n">stats</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>In the right plot above, the gray lines represent the single individuals, the black line denotes the average performance of a generation and the blue line indicates the performance of the best individual within each generation.
The horizontal black dashed line indicates the expected trial-to-trial variations of the experiment results with the parameterization from which we created our target length constant.
We can see, that with increasing generations the average deviation from our target length constant is decreasing.
Furthermore, we can see, that the best individuals are fluctuating and the deviation from the target value increases from time to time.
This can have two reasons.
First, mutation and recombination can alter the best performing individual such that its performance worsens, and second, since we work on an analog system, there are trial-to-trial variations.
Consequently not every hardware run will yield the same result.
However, both of this problems can be limited.</p>
<p>By employing a so called elitism-mechanism <a class="reference internal" href="#de75" id="id7"><span>[De75]</span></a> to our genetic algorithm, one can ensure that the best performing individual of a generation is guaranteed to be unaltered passed on to the next generation.
Therefore, the best fitness is preserved over the generations.</p>
<p>Trial-to-trial variations of the hardware can be reduced by repeating the experiment and averaging the resulting EPSPs.</p>
<p>Nevertheless, the above method should still provide us a sufficient chip parameterisation which results in our desired target length constant <span class="math notranslate nohighlight">\(\hat{\lambda}_\mathrm{emp}\)</span>.
Finally, we execute the experiment 10 times with the configuration provided by the best individual of the last generation of the genetic algorithm.
From the 10 runs we can get an estimate of the trial-to-trial variations.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">best_ind_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span><span class="n">ind</span><span class="o">.</span><span class="n">fitness</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">pop</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found parameters:</span><span class="se">\n</span><span class="s2">leak conductance:</span><span class="se">\t\t</span><span class="si">{</span><span class="n">pop</span><span class="p">[</span><span class="n">best_ind_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
      <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;inter-compartment conductance:</span><span class="se">\t</span><span class="si">{</span><span class="n">pop</span><span class="p">[</span><span class="n">best_ind_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">lambdas_repeated</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">popt</span> <span class="o">=</span> <span class="n">compartment_chain</span><span class="o">.</span><span class="n">run_and_eval</span><span class="p">(</span><span class="o">*</span><span class="n">pop</span><span class="p">[</span><span class="n">best_ind_index</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">lambdas_repeated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">popt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Average measured length constant: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">lambdas_repeated</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> +- &quot;</span>
      <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">lambdas_repeated</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Target length constant: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span>
      <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; +- </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline"></a></h2>
<dl class="citation">
<dt class="label" id="vb99"><span class="brackets"><a class="fn-backref" href="#id1">VB99</a></span></dt>
<dd><p>Michael C Vanier and James M Bower. A comparative survey
of automated parameter-search methods for compartmental
neural models. J Comput Neurosci, 7(2):149–171, 1999.
doi: 10.1023/a:1008972005316.</p>
</dd>
<dt class="label" id="bll01"><span class="brackets"><a class="fn-backref" href="#id2">BLL01</a></span></dt>
<dd><p>Thomas Berger, Matthew E. Larkum, and Hans-R. Lüscher.
High I(h) channel density in the distal apical dendrite of
layer V pyramidal cells increases bidirectional attenuation
of EPSPs. J. Neurophysiol., 85(2):855–868, 2001. doi:
10.1152/jn.2001.85.2.855.</p>
</dd>
<dt class="label" id="for-12"><span class="brackets"><a class="fn-backref" href="#id3">For+12</a></span></dt>
<dd><p>Félix-Antoine Fortin, François-Michel De Rainville, Marc-
André Gardner, Marc Parizeau, and Christian Gagné. DEAP:
Evolutionary algorithms made easy. Journal of Machine
Learning Research, 13:2171–2175, July 2012.</p>
</dd>
<dt class="label" id="gol89"><span class="brackets"><a class="fn-backref" href="#id4">Gol89</a></span></dt>
<dd><p>David E. Goldberg. Genetic Algorithms in Search, Optimization
and Machine Learning. Addison Wesley Longman Inc.,
1989. ISBN 0-201-15767-5.</p>
</dd>
<dt class="label" id="de75"><span class="brackets"><a class="fn-backref" href="#id7">De75</a></span></dt>
<dd><p>Kenneth Alan De Jong. An analysis of the behavior of a class
of genetic adaptive systems. PhD thesis, 1975.</p>
</dd>
</dl>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ts_03-multicompartment.html" class="btn btn-neutral float-left" title="Multicompartmental Neurons" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ts_05-yin_yang.html" class="btn btn-neutral float-right" title="Training an SNN on BrainScaleS-2 with PyTorch" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Electronic Vision(s).</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>